%clear

geometryParameters = struct(...
    'epsilon_t',-0.07053,...
    'epsilon_h',0.05067,...
    'iota',0.4542,...
    'G',3.7481,...
    'I',0,...
    'Nperiods',10,...
    'helicity_l',2,...
    'axisymmetric',false);

resolutionParameters = struct(...
    'NFourier', 100,...
    'Nxi', 16,...
    'includeConstraint', true);

NFourier2 = resolutionParameters.NFourier*2-1;

% Choose (m,n) pairs to use:
[ms,ns,Binv_vec] = chooseFourierModes(geometryParameters,resolutionParameters);
assignin('base','ns',ns)
assignin('base','ms',ms)

[ddtheta,ddzeta] = buildFourierDifferentiationMatrices(ms,ns,geometryParameters.Nperiods);
%{
assignin('base','ddtheta',ddtheta)
assignin('base','ddthetaf',full(ddtheta))
assignin('base','ddzeta',ddzeta)
assignin('base','ddzetaf',full(ddzeta))
%}


% Make a vector in mn-space that represents |B|:
Bvec = zeros(NFourier2,1);
% Constant term:
Bvec(1) = 1;
% Toroidal mode:
mask = (ms==1 & ns==0);
index = find(mask);
if numel(index) ~= 1
    error('Error! Did not find the toroidal mode!\n')
end
Bvec(index) = geometryParameters.epsilon_t;
% Helical mode:
mask = (ms==geometryParameters.helicity_l & ns==geometryParameters.Nperiods);
index = find(mask);
if numel(index) ~= 1
    error('Error! Did not find the helical mode!\n')
end
Bvec(index) = geometryParameters.epsilon_h;

BMatrix = buildFourierConvolutionMatrix(ms,ns,Bvec);
BinvMatrix = buildFourierConvolutionMatrix(ms,ns,Binv_vec);

BinvBMatrix = BinvMatrix*BMatrix;
BBinvMatrix = BMatrix*BinvMatrix;

figure(4)
clf
semilogy(abs(diag(BinvBMatrix)-1))
hold on
semilogy(abs(diag(BBinvMatrix)-1),':r')
title('Diagonals of BinvBMatrix and BBinvMatrix (difference from 1)')

figure(3)
clf
subplot(1,2,1)
imagesc(log10(abs(BinvBMatrix)))
title('BinvBMatrix')
colorbar

subplot(1,2,2)
imagesc(log10(abs(BBinvMatrix)))
title('BBinvMatrix')
colorbar

% **********************************************************
% Verify that the convolution matrix generated by only the m=n=0 component
% is the identity matrix:
% **********************************************************

constVec = 0*Bvec;
constVec(1)=1;
shouldBeEye = buildFourierConvolutionMatrix(ms,ns,constVec);

figure(10)
clf
imagesc(shouldBeEye)
colorbar
title('shouldBeEye')

%{
assignin('base','shouldBeEye',buildFourierConvolutionMatrix(ms,ns,constVec))


assignin('base','Bvec',Bvec)
assignin('base','Binv_vec',Binv_vec)
assignin('base','BMatrix',BMatrix)
assignin('base','BinvMatrix',BinvMatrix)
assignin('base','BBinvMatrix',BMatrix*BinvMatrix)
assignin('base','BinvBMatrix',BinvMatrix*BMatrix)
%}

% **********************************************************
% Use a broader range of m and n, and a pattern that involves both sin and
% cos terms.
% **********************************************************

mmax=16;
nmax=17;
% For m=0, we have n=0 to nmax.
% For m>0, we have n=-nmax to nmax.
NFourier = (nmax*2+1)*mmax + nmax + 1;
ns2 = zeros(NFourier,1);
ms2 = zeros(NFourier,1);
ns2(2:(nmax+1)) = (1:nmax)';
nextIndex = nmax+2;
for m=1:mmax
    indices = (1:(2*nmax+1)) + nextIndex-1;
    ms2(indices) = m;
    ns2(indices) = ((-nmax):nmax)';
    nextIndex = nextIndex + 2*nmax+1;
end


Ntheta = 2*mmax*2+3;
Nzeta = 2*nmax*2+3;

% Build theta grid:
theta = linspace(0,2*pi,Ntheta+1);
theta(end)=[];

zetaMax = 2*pi;
zeta = linspace(0,zetaMax,Nzeta+1);
zeta(end)=[];

[zeta2D, theta2D] = meshgrid(zeta,theta);

% Make up some function that involves both sin and cos terms
B = 5+exp(sin(theta2D+1-zeta2D)) + log(1.2+cos(zeta2D+0.5)) - sqrt(1.3+sin(theta2D*2-zeta2D-0.7));
%B = 2+sin(theta2D*2 - zeta2D);
%B = 10+sin(3*theta2D);
%B = 10+cos(3*theta2D);
%B = 10+zeros(size(theta2D));
%B = sin(2*zeta2D);

figure(5)
clf
imagesc(B)
title('B')
colorbar

Binv = 1./B;
Bsq = B.*B;

% (slow) Fourier transform
m1D = 0:mmax;
n1D = (-nmax):nmax;
[n2D, m2D] = meshgrid(n1D,m1D);
B_Fourier2D_sin = zeros(size(n2D));
Bsq_Fourier2D_sin = zeros(size(n2D));
Binv_Fourier2D_sin = zeros(size(n2D));
B_Fourier2D_cos = zeros(size(n2D));
Bsq_Fourier2D_cos = zeros(size(n2D));
Binv_Fourier2D_cos = zeros(size(n2D));

for m=0:mmax
    if m==0
        nmin=0;
    else
        nmin = -nmax;
    end
    for n=nmin:nmax
        if m==0 && n==0
            factor=1/ (Ntheta*Nzeta);
        else
            factor=2/ (Ntheta*Nzeta);
        end
        angle = m*theta2D-n*zeta2D;
        sinangle = sin(angle);
        cosangle = cos(angle);
        B_Fourier2D_cos(m+1,n+nmax+1) = factor*sum(sum(cosangle.*B));
        Bsq_Fourier2D_cos(m+1,n+nmax+1) = factor*sum(sum(cosangle.*Bsq));
        Binv_Fourier2D_cos(m+1,n+nmax+1) = factor*sum(sum(cosangle.*Binv));
        if m~=0 || n~=0
            B_Fourier2D_sin(m+1,n+nmax+1) = factor*sum(sum(sinangle.*B));
            Bsq_Fourier2D_sin(m+1,n+nmax+1) = factor*sum(sum(sinangle.*Bsq));
            Binv_Fourier2D_sin(m+1,n+nmax+1) = factor*sum(sum(sinangle.*Binv));
        end
    end
end


s = numel(m2D);
m2D_reshaped = reshape(m2D,[s,1]);
n2D_reshaped = reshape(n2D,[s,1]);
B_Fourier2D_sin_reshaped = reshape(B_Fourier2D_sin,[s,1]);
B_Fourier2D_cos_reshaped = reshape(B_Fourier2D_cos,[s,1]);
Bsq_Fourier2D_sin_reshaped = reshape(Bsq_Fourier2D_sin,[s,1]);
Bsq_Fourier2D_cos_reshaped = reshape(Bsq_Fourier2D_cos,[s,1]);
Binv_Fourier2D_sin_reshaped = reshape(Binv_Fourier2D_sin,[s,1]);
Binv_Fourier2D_cos_reshaped = reshape(Binv_Fourier2D_cos,[s,1]);

B_vec2 = zeros(NFourier*2-1,1);
Bsq_vec2 = zeros(NFourier*2-1,1);
Binv_vec2 = zeros(NFourier*2-1,1);

for imn = 1:NFourier
    index = find(ms2(imn)==m2D_reshaped & ns2(imn)==n2D_reshaped);
    if numel(index) ~= 1
        error('Should not get here!')
    else
        B_vec2(imn) = B_Fourier2D_cos_reshaped(index);
        Bsq_vec2(imn) = Bsq_Fourier2D_cos_reshaped(index);
        Binv_vec2(imn) = Binv_Fourier2D_cos_reshaped(index);
        if ms2(imn)~=0 || ns2(imn)~=0
            B_vec2(imn+NFourier-1) = B_Fourier2D_sin_reshaped(index);
            Bsq_vec2(imn+NFourier-1) = Bsq_Fourier2D_sin_reshaped(index);
            Binv_vec2(imn+NFourier-1) = Binv_Fourier2D_sin_reshaped(index);
        end
    end
end

BMatrix2 = buildFourierConvolutionMatrix(ms2,ns2,B_vec2);
BsqMatrix2 = buildFourierConvolutionMatrix(ms2,ns2,Bsq_vec2);
BinvMatrix2 = buildFourierConvolutionMatrix(ms2,ns2,Binv_vec2);

BinvBMatrix2 = BinvMatrix2*BMatrix2;
BBinvMatrix2 = BMatrix2*BinvMatrix2;
BMatrix2_squared = BMatrix2*BMatrix2;

figure(24)
clf
semilogy(abs(diag(BinvBMatrix2)-1))
hold on
semilogy(abs(diag(BBinvMatrix2)-1),':r')
title('Diagonals of BinvBMatrix2 and BBinvMatrix2 (difference from 1)')

figure(23)
clf
subplot(1,2,1)
imagesc(log10(abs(BinvBMatrix2)))
title('BinvBMatrix2')
colorbar

subplot(1,2,2)
imagesc(log10(abs(BBinvMatrix2)))
title('BBinvMatrix2')
colorbar

figure(25)
clf
subplot(1,3,1)
imagesc(log10(abs(BsqMatrix2)))
title('BsqMatrix2')
colorbar

subplot(1,3,2)
imagesc(log10(abs(BMatrix2_squared)))
title('BMatrix2_squared')
colorbar

subplot(1,3,3)
%imagesc(log10(abs(BMatrix2_squared-BsqMatrix2)))
imagesc(abs(BMatrix2_squared-BsqMatrix2))
title('BMatrix2_squared - BsqMatrix2')
colorbar



